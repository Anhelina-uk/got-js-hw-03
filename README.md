# goit-js-hw-01

#### **Базова термінологія JavaScript**

`Синтаксис у програмуванні` визначає набір конструкцій, за якими створюється
програма. Наприклад, яка правильна послідовність використання ключових слів та
символів, де необхідна ;, а де :, різниця між одинарними ‘’, парними “” або
косими ```` лапками тощо. Синтаксис дуже важливий. Якщо в коді є навіть
найдрібніша помилка, програма не виконається.

`Код` — це набір інструкцій, які комп'ютер може зрозуміти й виконати.

`Вихідний код (source code)` — це текст комп'ютерної програми будь-якою мовою
програмування. Він містить набір синтаксичних конструкцій, що описують набір
інструкцій для комп'ютера.

`Компілятор і інтерпретатор `— це програми, які використовуються для
перетворення коду, написаного на високорівневих мовах програмування, у машинний
код, який може виконувати комп'ютер.

\*\*Компілятор:

- Принцип роботи: Компілятор аналізує весь вихідний код програми і перетворює
  його у машинний код або байт-код за один раз, створюючи виконуваний файл.
- Виконання: Після компіляції програма може виконуватися без необхідності
  повторного аналізу коду. Це робить виконання програми швидшим, оскільки немає
  потреби в додаткових трансформаціях під час виконання.
- Приклад мов: C, C++, Rust — це мови, які зазвичай компілюються.

\*\*Інтерпретатор:

- Принцип роботи: Інтерпретатор читає і виконує код по рядку або по частинах, не
  створюючи окремого виконуваного файлу.
- Виконання: Виконання коду відбувається безпосередньо, що може призвести до
  повільнішої роботи програми, оскільки код аналізується кожного разу при
  виконанні.
- Приклад мов: Python, JavaScript, Ruby — це мови, які зазвичай інтерпретуються.

`Алгоритм` — це набір кроків, які потрібно виконати задля досягнення певної
мети. Алгоритми можуть бути використані в різних сферах, таких як комп'ютерні
науки, математика, повсякденне життя тощо. Вони можуть бути представлені різними
способами, такими як текст, діаграми, псевдокод або програмний код.

Основні характеристики алгоритму:

- Чіткість: Кожен крок алгоритму повинен бути зрозумілим і однозначним.
- Скінченність: Алгоритм повинен завершуватися після виконання скінченної
  кількості кроків.
- Вхідні дані: Алгоритм може мати вхідні дані, які потрібно обробити.
- Вихідні дані: Алгоритм має повертати результати виконання, які є вихідними
  даними.
- Універсальність: Алгоритм повинен бути застосовний для різних наборів вхідних
  даних.

Алгоритми широко використовуються у програмуванні для вирішення різноманітних
задач, таких як:

- Сортування даних (наприклад, алгоритм сортування бульбашкою, quicksort).
- Пошук інформації (наприклад, бінарний пошук).
- Обробка зображень (алгоритми для фільтрації або стиснення).
- Вирішення математичних задач (наприклад, алгоритм Евкліда для знаходження
  найбільшого спільного дільника).

#### **Мова JavaScript**

`JavaScript` — високорівнева мова програмування, що підтримується всіма
сучасними веббраузерами. У Front-end розробці JavaScript використовується у
зв'язці з HTML та CSS для забезпечення функціональності вебсторінки, такої як:

- нескладні обчислення;
- перевірка та маніпуляція даними, які було введено користувачем;
- зберігання інформації у браузері користувача;
- динамічна зміна HTML-документа;
- реакція на дії користувача;
- створення інтерактивних елементів: галерей, графіків тощо;
- взаємодія з бекендом.

Також на сьогоднішній день, використовуючи JavaScript, можна створювати:

- вебдодатки на фреймворках React, Vue, Angular тощо;
- бекенд програми на Node.js ;
- мобільні додатки на React Native ;
- десктоп програми за допомогою Electron .

`Інструкція (statement)` — це пов'язаний набір слів і символів із синтаксису
мови, які об'єднуються, щоб висловити одну ідею, тобто одну інструкцію для
машини.

приклад інструкції:

**a = b \* 2;**

У JavaScript інструкції закінчуються ; крапкою з комою, яку можна порівняти з
крапкою в кінці речення твоєю рідною мовою. a і b — змінні (як у рівнянні
алгебри). Змінні — це сховища даних, які використовує програма. Вони складаються
з ідентифікатора (імені) та пов'язаного з ним значення. Детальніше розберемо, що
таке змінні, трохи пізніше. 2 — просто число. Це називається значенням літералу
(literal value), оскільки воно не зберігається у змінній. = і \* — оператори, що
виконують дії над значеннями та змінними.

#### **Вираз та літерал**

`Вираз (Expression)`— це комбінація змінних, операторів та значень, яка може
бути обчислена для отримання результату. Вираз може включати арифметичні
операції, логічні операції, виклики функцій та інші конструкції.

`Літерал (Literal)`— це фіксоване значення, яке безпосередньо вказується у коді.
Літерали можуть представляти різні типи даних, такі як числа, рядки, булеві
значення, масиви та об'єкти. **Літерали** — це фіксовані значення, які
безпосередньо написані у коді. Числовий літерал — це число, записане в коді
програми. Рядковий літерал — це послідовність символів, укладених у лапки.

#### **Підключення скрипта**

Для підключення скрипта JavaScript до HTML-сторінки можна використати тег

`script`. Існує кілька способів, як це можна зробити:

- Вбудований скрипт-Можна додати JavaScript-код прямо всередині тега <script>
  всередині тега <head>:
- Зовнішній скрипт-По-перше, треба створити окремий файл із розширенням .js, що
  містить JavaScript-код. Потім під'єднати цей файл до HTML-сторінки за
  допомогою тега <script>, вказавши шлях до файлу в атрибуті src: \*\*\_Тег
  <script> з атрибутом defer можна вставити як у <head>, так і в <body> — немає
  жодної різниці._**

Атрибут `defer` вказує браузеру, що скрипт повинен бути виконаний після того, як
HTML-документ буде повністю завантажений. Це дозволяє уникнути затримки
відображення вмісту сторінки.

У багатьох випадках краще використовувати зовнішні скрипти, щоб зробити код
більш читабельним, зручним для підтримки та перевикористання.

**Суворий режим** Суворий режим (англ. strict mode) у JavaScript — це
спеціальний режим виконання коду, який дає змогу переводити скрипт у режим
повної відповідності сучасному стандарту. Це запобігає певним помилкам,
наприклад, використанню небезпечних і застарілих конструкцій, що робить код
надійнішим та дозволяє легше його підтримувати.

Щоб увімкнути суворий режим, потрібно додати директиву 'use strict'; на початок
скрипта. Наприклад:

`'use strict'; // Код у суворому режимі`

**Виведення даних** Розробнику потрібно перевіряти правильність роботи програми
в певний момент часу та виводити інформацію в певному місці коду. Для цього є
консоль в інструментах розробника браузера на вкладці Console. Наступні
комбінації клавіш відкривають інструменти розробника на вкладці Console: Windows
і Linux — Ctrl + Shift + J; MacOS — Command + Option + J .

#### **Метод console.log()**

Щоб вивести дані в консоль розробника використовується метод `console.log()`.

console.log(value); Значення value, яке вказано в круглих дужках, буде виведено
в консоль розробника при виконанні програми.

console.log("JavaScript is awesome!"); console.log(10); При виконанні цього коду
в консоль розробника будуть послідовно виведені рядок і число.

#### **Змінні та типи даних**

`Оголошення змінних` `Змінна` — це контейнер, який використовується для
зберігання даних. Змінна складається з:

- ідентифікатора (унікального імені);
- області памяті, де зберігається її значення. Змінну можна уявити, як коробку з
  написом (іменем), у якій щось лежить (значення).

У JavaScript оголошення змінних може виконуватися за допомогою трьох основних
ключових слів: var, let та const. Кожне з них має свої особливості і
використовується в різних контекстах.

- **`var`**: Використовуйте для змінних зі старим кодом, але будьте обережні з
  підняттям.
- **`let`**: Використовуйте для змінних, які можуть змінюватися в межах блоку.
- **`const`**: Використовуйте для констант, які не повинні змінюватися.

Після ключового слова, через пробіл, вказується ім'я змінної (у прикладі: age та
username). Щоб присвоїти змінній значення, використовують оператор присвоєння =
Інструкція оголошення змінної закінчується крапкою з комою ; .

**Перевизначення значення** Для перевизначення значення раніше оголошеної
змінної треба після імені такої змінної поставити літерал присвоєння`=`і після
нього записати нове значення. Для оголошення змінної, якій згодом можна задати
нове значення, використовується ключове слово `let`.

`Змінним, оголошеним через let, необов'язково відразу задавати значення. У разі оголошення змінної без значення, змінна ініціалізується зі спеціальним значенням undefined (англ. не визначено).`

**різниця між `const` і `let`**

Основна відмінність між const і let полягає в можливості перевизначення значення
змінної після її оголошення. Ключове слово `const` запобігає перевизначенню
значення для змінної. Ключове слово `let` дозволяє змінювати значення змінної
після її оголошення.

Правило використання const та let може бути таким: — Використовуй const за
замовчуванням для оголошення змінних. — Використовуй let, якщо потрібно
змінювати значення змінної під час виконання скрипту. Це правило допоможе писати
більш надійний, зрозумілий код, який легко підтримувати.

**Найменування**

1. Імена змінних можуть складатися з літер (a-z, A-Z), цифр (0-9), символів
   підкреслення (\_) та знака долара ($).
2. Першим символом в імені змінної має бути літера латиниці, символ підкреслення
   або знак долара. Інші символи можуть бути будь-якими з допустимих.
3. Імена змінних чутливі до регістру, тобто змінні user, usEr та User вважаються
   різними змінними. При camelCase нотації \*\*\*\*перше слово пишеться малими
   літерами, а кожне наступне починається з великої літери, наприклад: user,
   getUserData, isActive, activeGuestCount

`!!!` існують зарезервовані ключові слова. Ці слова мають спеціальне значення та
використовуються для певних конструкцій у мові. Не можна використовувати ключові
слова як імена змінних, оскільки це спричинить помилки в коді.

**Типи даних**

Примітивні типи даних використовуються для зберігання та обробки різних видів
інформації у програмі. JavaScript змінна не обмежена певним типом даних, тому
може зберігати значення різних типів.

Числа `(Number)` можуть бути позитивними чи негативними, цілими або дробовими.
Ціла та дробова частини числа розділяються крапкою. const age = 20; const salary
= 3710.84;

Рядок `(String)` є послідовністю символів, вкладених в одинарні '' або подвійні
лапки "". const username = 'Mango995'; const description = "JavaScript is
awesome!";

Логічний тип даних `(Boolean)` має лише два значення: true і false. На відміну
від рядків, логічний тип даних пишеться без лапок. Порівняй: true — це логічне
значення; "true" — це рядок, що містить слово true.

**Спеціальні значення**

У JavaScript існують два спеціальні значення: `null` і `undefined`. Обидва
означають відсутність значення.

`null` явно вказує на відсутність значення та часто використовується
розробниками для позначення порожнього значення. Це значення має бути явно
присвоєно змінній, щоб вказати, що змінна не містить ніяких дійсних даних.

Значення `undefined` автоматично присвоюється змінній, якщо:

1. змінній було явно задано значення undefined ; змінна була оголошена, але ще
   не була ініціалізована значенням.

2. Значення undefined вказує на невизначеність значення змінної, тобто каже нам,
   що значення на даний момент невідоме чи невизначене.

**Оператор `typeof`**

Оператор `typeof` використовується для визначення типу даних значення або
виразу.

const quantity = `17`; console.log(typeof quantity);

// виведе `"number"`

const message = `"JavaScript is awesome!"`; console.log(typeof message);

// виведе `"string"`

const isSidebarOpen = `false`; console.log(typeof isSidebarOpen);

// виведе `"boolean"`

let username; console.log(typeof username);

// виведе `"undefined"`

let status = `null`; console.log(typeof status);

// виведе `"object"`

**Арифметичні операції**

Оператор `(+)` використовується для складання двох чисел.

Оператор `(-)` використовується для віднімання одного числа від іншого.

Оператор `(*)` використовується для множення двох чисел.

Оператор `(/)` використовується для ділення одного числа на інше.

Оператор `(%)` повертає остачу від ділення одного числа на інше.

Оператор `(**)` використовується для піднесення числа до степеня.

**Комбіновані оператори**

`Додавання`: +=. Приклад: x += y еквівалентно x = x + y

`Віднімання`: -=. Приклад: x -= y еквівалентно x = x - y

`Множення`: _=. Приклад: x _= y еквівалентно x = x \* y

`Ділення`: /=. Приклад: x /= y еквівалентно x = x / y

`Остача від ділення`: %=. Приклад: x %= y еквівалентно x = x % y

#### **Рядки**

**Конкатенація рядків**

Якщо застосувати оператор + до рядка та будь-якого іншого типу даних,
результатом буде новий рядок, що містить об'єднання вихідних значень. Це
називається `конкатенація (склеювання)`.

Під час конкатенації можна використовувати значення змінних, щоб складати рядки
з динамічними значеннями. Для цього необхідно вказати ім'я змінної, у це місце
буде підставлено її значення. Під час конкатенації будь-який тип даних буде
приведено до рядка та поєднано з іншим рядком. Проте порядок операндів має
значення. Перетворення типів відбувається лише в момент операції додавання з
рядком. До цього моменту застосовуються нормальні правила математики.

console.log(1 + "2"); // "12" console.log(1 + "2" + 4); // "124" console.log(1 +
2 + "4"); // "34"

В останньому прикладі спочатку виконується математичне додавання для перших двох
чисел 1 і 2, потім число 3 перетворюється на рядок "3" і поєднується з рядком
"4".

**Перетворення типів: `рядки`**

Перетворення типів у JavaScript — це процес зміни значення одного типу даних на
інший тип даних. Перетворення типів може відбуватися в різних ситуаціях,
наприклад, під час виконання арифметичних операцій з різними типами даних або
порівняння значень.

`Явне перетворення типів` виконується програмістом і використовується за
потребою. Для перетворення будь-якого значення на рядок можна використовувати
вбудовану функцію String(), яка повертає результат у вигляді рядка.

console.log(String(5)); // "5"

console.log(String(true)); // "true"

console.log(String(false)); // "false"

console.log(String(null)); // "null"

console.log(String(undefined)); // "undefined"

`Неявне перетворення типів` відбувається автоматично під час виконання операцій
або обчислень. Наприклад, якщо виконується операція додавання (+) між рядком та
іншим типом даних, JavaScript автоматично перетворює значення операнда на рядок
і виконує конкатенацію рядків.

console.log("5" + 3); // "53"

console.log("5" + true); // "5true"

console.log("5" + false); // "5false"

console.log("5" + null); // "5null"

console.log("5" + undefined); // "5undefined"

**Шаблонні рядки**

Шаблонні рядки — це синтаксис, який полегшує об'єднання статичного тексту з
динамічним (тобто текстом, що містить змінні, обчислення тощо). Шаблонні рядки
дозволяють уникати користування заплутаною конкатенацією та роблять код більш
читабельним.

**_Синтаксис шаблонного рядка_**

Шаблонні рядки огортаються зворотними лапками (англ. backticks) ` (``) `

Шаблонні рядки дозволяють підставляти значення змінних безпосередньо всередині
рядка за допомогою синтаксису інтерполяції `${змінна}.`

**Інтерполяція рядків** — це спосіб вставляти значення змінних і виразів
безпосередньо в рядковий літерал через плейсхолдери, які обчислюються під час
виконання.

**Довжина рядка**

Довжина рядка визначається кількістю символів у ньому. Щоб дізнатися довжину
рядка, використовується вбудована властивість `length`. Щоб отримати значення
цієї властивості, необхідно звернутися до неї через крапку після імені змінної
чи рядкового літералу.

const productName = "Repair droid";

`// Якщо у змінній зберігається рядок` console.log(productName.length); // 12

`// Якщо рядковий літерал` console.log("Repair droid".length); // 12

Використання властивості `length` дозволяє легко визначити довжину будь-якого
рядка та використовувати цю інформацію для виконання різних операцій і
перевірок.

**Індексація рядків**

Рядки — це набори символів, де кожен символ має свій порядковий номер (індекс).
Індексація елементів рядка починається з нуля. Перший символ має індекс 0,
другий — індекс 1, третій — 2 і так далі.

Для доступу до певного символу рядка ми використовуємо синтаксис квадратних
дужок, де вказуємо індекс потрібного символу: string[index], тобто
рядок[індекс].

Отримання останнього символу рядка можливе за його індексом `string[lastIndex]`.
Щоб знайти індекс останнього символу рядка, треба від довжини цього рядка
відняти одиницю `string.length - 1`

const product = "Repair droid";

const lastElementIndex = product.length - 1;

console.log(product[lastElementIndex]); // 'd'

Для доступу до останнього символу рядка без створення проміжної змінної ми
можемо вставити вираз `(product.length - 1)` безпосередньо у квадратні дужки при
зверненні до елемента.

const product = "Repair droid";

console.log(product[product.length - 1]); // 'd'

_Приклад_

const courseTopic = "JavaScript essentials";

const courseTopicLength = courseTopic.length; // Довжина рядка

const firstElement = courseTopic[0]; // Перший символ

const lastElement = courseTopic[courseTopic.length-1]; // Останній

**Оператори рівності**

У JavaScript існують оператори рівності, які дозволяють порівнювати значення та
визначати їхню рівність або нерівність.

_*Оператори несуворої рівності:*_

1. Оператор == (дорівнює) — порівнює два значення на рівність і повертає true,
   якщо значення операндів рівні. Якщо навпаки, повертає false

2. Оператор != (не дорівнює) — порівнює два значення на нерівність і повертає
   true, якщо значення операндів не рівні. Якщо навпаки, повертає false

_*Оператори суворої рівності:*_

1. Оператор === (сувора рівність) — порівнює два значення на рівність, повертає
   true, якщо значення операндів рівні та мають однаковий тип даних. В іншому
   випадку, повертає false

2. Оператор !== (сувора нерівність) — порівнює два значення на нерівність,
   повертає true, якщо значення операндів не рівні або мають різні типи даних. В
   іншому випадку, повертає false

**Перетворення типів: числа**

Для `явного перетворення` будь-якого значення в число можна використовувати
вбудовану функцію `Number()`, яка повертає результат у вигляді числа.

При перетворенні до числа:

1. true завжди приводиться до 1;
2. false , null і "" завжди приводяться до 0.

Якщо неможливо привести значення до числа, результатом перетворення буде
спеціальне значення NaN (Not a Number).

Арифметичні операції `(+, -, *, /)` виконують `неявне перетворення типів`. Якщо
у виразі присутній хоча б один із операндів з типом рядка, то обидва операнди
приводяться до чисел. Це відбувається у всіх арифметичних операціях, окрім
додавання. Памятай, що + біля рядкових операндів викликає їх з'єднання
(конкатинацію).

Для всіх інших типів операндів та операцій виконується перетворення операндів до
числа.

У разі використання операторів порівняння `(<, >, <=, >=)` також виконується
неявне перетворення типів. Якщо операнди різних типів, то перед порівнянням вони
приводяться до числа.

**Перетворення рядків у числа**

Метод `Number.parseInt()` приймає 2 аргументи:

1. Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений у рядок
2. Система числення, до якої відноситься рядок (не обовязковий аргумент, за
   замовчуванням десяткова система). Наприклад, для десяткової системи буде 10,
   для шістнадцяткової - 16 тощо..

Метод аналізує рядок зліва направо, видаляючи пробіли на початку і перетворюючи
допустимі символи у число до тих пір, поки не зіткнеться з першим недопустимим
символом. Після цього аналіз припиняється, і вже перетворене ціле число
повертається.

Якщо перші символи рядка не можуть бути перетворені на число, або рядок порожній
чи відсутній, результатом буде значення NaN (Not a Number).

console.log(Number.parseInt("5")); // 5

console.log(Number.parseInt("5.5")); // 5

console.log(Number.parseInt("5cm")); // 5

console.log(Number.parseInt("12qwe74")); // 12

console.log(Number.parseInt("12.46qwe79")); // 12

console.log(Number.parseInt("cm5")); // NaN

console.log(Number.parseInt("")); // NaN

console.log(Number.parseInt("qweqwe")); // NaN

Метод `Number.parseFloat()`аналогічний Number.parseInt() з однієї відмінністю:
перетворює рядок на число з плаваючою крапкою.

console.log(Number.parseFloat("5")); // 5

console.log(Number.parseFloat("5.5")); // 5.5

console.log(Number.parseFloat("3.14")); // 3.14

console.log(Number.parseFloat("5cm")); // 5

console.log(Number.parseFloat("5.5cm")); // 5.5

console.log(Number.parseFloat("12qwe74")); // 12

console.log(Number.parseFloat("12.46qwe79")); // 12.46

console.log(Number.parseFloat("cm5")); // NaN

console.log(Number.parseFloat("")); // NaN

console.log(Number.parseFloat("qweqwe")); // NaN

**Арифметичні функції**

Клас Math є вбудованим класом JavaScript. Цей клас надає набір методів для
виконання математичних операцій та роботи з числами.

`Math.floor(num)`: повертає найближче ціле число, яке є меншим або дорівнює
вказаному числу num. Наприклад:

console.log(Math.floor(1.3)); // 1

console.log(Math.floor(1.7)); // 1

`Math.ceil(num)`: повертає найближче ціле число, яке є більшим, або дорівнює
зазначеному числу num. Наприклад:

console.log(Math.ceil(1.3)); // 2

console.log(Math.ceil(1.7)); // 2

`Math.round(num)`: повертає значення числа після округлення до найближчого
цілого. Округлення відбувається за математичними правилами, якщо десяткова
частина числа менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше —
то в більшу.

console.log(Math.round(1.3)); // 1

console.log(Math.round(1.7)); // 2

`Math.max(num1, num2, ...)`: повертає найбільше число з набору переданих чисел.
Наприклад:

console.log(Math.max(20, 10, 50, 40)); // 50

`Math.min(num1, num2, ...)`: повертає найменше число з набору переданих чисел.
Наприклад:

console.log(Math.min(20, 10, 50, 40)); // 10

`Math.random()`: повертає випадкове число в діапазоні від 0 (включно) до 1 (за
винятком). Наприклад:

console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ...
0.9166353649342294

**Дробове число**

При виконанні операцій з дробовими числами можуть виникати неточності через
внутрішнє представлення чисел у пам'яті комп'ютера.

Наприклад, результат 0.1 + 0.2 не дорівнює 0.3. Число 0.1 у двійковій системі
числення, яку використовує комп'ютер — це нескінченний дріб. Двійкове значення
нескінченних дробів зберігається лише до певного знака, тому виникає неточність.
При додаванні 0.1 і 0.2 дві неточності складаються, виходить незначна, але все ж
таки помилка в обчисленнях.

console.log(0.1 + 0.2 === 0.3); // false

console.log(0.1 + 0.2); // 0.30000000000000004

**Як виправити цю проблему**

1. Підхід 1.

Помножити числа на досить велике число (наприклад, 10 або 100).

Виконати додавання.

Розділити результат на те саме число, щоб повернути його до початкового
масштабу.

console.log(0.1 _ 10 + 0.2 _ 10); // 3

console.log((0.1 _ 10 + 0.2 _ 10) / 10); // 0.3

2. Підхід 2.

Використовувати метод числа `toFixed()` для округлення результату до певної
кількості знаків після крапки. Метод `toFixed()` повертає рядок, що представляє
число із зазначеною кількістю знаків після крапки. Таким чином, ми можемо
отримати заокруглений результат з необхідною точністю.

console.log((0.1 + 0.2).toFixed(1)); // "0.3"

console.log((5).toFixed(2)); // '5.00'

console.log((8.762195).toFixed(4)); // '8.7622'

#### **Основи функцій**

**_Оголошення та виклик функції_**

Функція — це незалежний блок коду, який виконує певну задачу з різними
початковими значеннями. Функцію можна представити, як чорну скриньку, яка
приймає дані на вході та повертає результат на виході після виконання коду
всередині функції.

`Оголошення функції має таку структуру:`

1. Ключове слово function
2. Ім'я функції — це дієслово, що відповідає на питання "Що зробити?"
3. Пара круглих дужок ()
4. Тіло функції у фігурних дужках {}

function doStuff() {

// Тіло функції

console.log('Log inside multiply function'); }

**Виклик функції**

Коли функцію потрібно виконати, вона викликається за допомогою її імені та пари
круглих дужок.

// Оголошення функції multiply

function doStuff() {

// Тіло функції

console.log('Log inside multiply function'); }

// Виклики функції multiply

doStuff(); // 'Log inside multiply function'

**Параметри та аргументи**

`Параметри` — це локальні змінні, доступні лише всередині тіла функції.

У круглих дужках після імені функції вказуються параметри. Параметри є
перерахуванням даних, які очікує функція під час виклику.

Параметри розділяються комами. Функція може мати будь-яку кількість параметрів
або не мати їх взагалі, у такому випадку вказуються просто порожні круглі дужки.

// Оголошення параметрів x, y, z

function multiply(x, y, z) {

console.log(`Result: ${x * y * z}`); }

Під час виклику функції в круглих дужках можна `передати аргументи`, які є
значеннями для оголошених параметрів функції.

// Оголошення параметрів x, y, z

function multiply(x, y, z) {

console.log(`Result: ${x * y * z}`); }

// Передача аргументів

multiply(2, 3, 5); // "Result: 30"

multiply(4, 8, 12); // "Result: 384"

multiply(17, 6, 25); // "Result: 2550"

`!!!`

function calculate(x, y) {}

calcualate(5, 8);

`Параметри` — це локальні змінні, що вказуються у круглих дужках після імені
функції (x, y) . А `аргументи` — це значення для оголошених параметрів функції.
Отже, 5 і 8 — це аргументи.

**Повернення значення**

Оператор 'return' у JavaScript (і в багатьох інших мовах програмування)
використовується в функціях для того, щоб повернути значення з функції назад
туди, звідки вона була викликана. Коли функція виконується і досягає оператора
return, вона завершує свою роботу і повертає вказане значення.

`Приклад 1: Повернення числа`

У цьому прикладі функція add приймає два числа, додає їх і повертає результат.
Ми зберігаємо його в змінну result і виводимо в консоль.

function add(a, b) {

    return a + b; // Повертає суму a і b

}

const result = add(5, 3); // Викликаємо функцію і зберігаємо результат

console.log(result); // Виведе: 8

`Приклад 2: Повернення рядка`

Тут функція greet приймає ім'я і повертає рядок з привітанням. Ми знову
зберігаємо результат у змінну і виводимо його.

function greet(name) {

    return "Hello, " + name + "!"; // Повертає привітання

}

const message = greet("Alice"); // Викликаємо функцію з аргументом "Alice"

console.log(message); // Виведе: Hello, Alice!

`Приклад 3: Завершення функції`

У цьому прикладі, якщо вік менше 18, функція повертає повідомлення про те, що ви
занадто молоді, і вона закінчує свою роботу. Якщо вік 18 або більше, то
повертається інше повідомлення

function checkAge(age) {

    if (age < 18) {

        return "You are too young."; // Якщо вік менше 18, повертаємо повідомлення
    }
    return "You are an adult."; // Інакше повертаємо інше повідомлення

}

console.log(checkAge(15)); // Виведе: You are too young.

console.log(checkAge(20)); // Виведе: You are an adult.

**Порядок виконання коду**

Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання поточного
коду й починає виконувати код з тіла функції.

Після того, як весь код у функції буде виконано, інтерпретатор повертає
управління в те місце, звідки був здійснений виклик функції, і продовжує
виконання коду програми, що залишився.

**Область видимості функції**

Область видимості функції (або `scope` функції) — це контекст, у якому змінні
доступні для використання.Область видимості визначає, де змінна доступна для
використання. Глобальні змінні доступні скрізь, локальні — тільки в межах
функцій, а блочні — тільки в межах певного блоку коду.

1. Глобальна область видимості

Змінні, оголошені поза будь-якої функції, мають глобальну область видимості.
Вони доступні з будь-якої частини коду.

2. Локальна область видимості

Змінні, оголошені всередині функції, мають локальну область видимості. Вони
доступні тільки всередині цієї функції.

3. Блочна область видимості

Змінні, оголошені за допомогою let або const в блоці (наприклад, в циклі або
умовному операторі), мають блочну область видимості.

# goit-js-hw-02

#### **Розгалуження**

**Інструкція `if`**

Інструкція `if` дозволяє виконати певний блок коду тільки в тому випадку, якщо
задана умова істинна (тобто приймає значення true).

Коли інтерпретатор зустрічає інструкцію if, він обчислює вказану умову в круглих
дужках (condition), перетворюючи її до логічного типу (boolean). Якщо умова
(condition) перетворюється до `true`, виконується блок коду, написаний у
фігурних дужках {} — (statement).

Якщо умова (condition) перетворюється до `false`, блок коду не виконається і
продовжиться виконання програми, що іде після інструкції if.

**Інструкція `if...else`**

Якщо умова (condition) перетворюється до `true`, то виконається код блоку `if`
(if block statements).

Якщо умова (condition) перетворюється до `false`, то виконається код блоку
`else` (else block statements).

**лок `else...if`**

Конструкція else...if розширює конструкцію if...else і дозволяє перевірити та
зреагувати на виконання або невиконання `кількох умов`.

const grade = 85;

if (grade >= 90) {

console.log("Perfectly");

} else if (grade >= 80) {

console.log("Good");

} else if (grade >= 70) {

console.log("Satisfactorily");

} else {

console.log("Unsatisfactorily"); }

**Тернарний оператор**

`Тернарний оператор` — це коротша синтаксична заміна інструкції if...else.
Тернарний оператор дозволяє виконувати певну частину коду залежно від умови.

`<condition> ? <expression if condition is true> : <expression if condition is false>`

Тернарний оператор рекомендується використовувати у найпростіших випадках
операції присвоєння чи повернення. Однак не рекомендується використовувати його
для складних розгалужень, оскільки це може ускладнити читання та розуміння коду.

**Оператор `switch`**

Оператор `switch` дозволяє виконувати різні дії залежно від значення виразу.
Використання switch є більш компактним і зручним способом для порівняння виразів
з кількома варіантами, ніж інструкції `if...else та else...if.`

const fruit = 'apple';

switch (fruit) {

case 'apple':

    console.log('Apple selected');

    break;

case 'banana':

    console.log('Banana selected');

    break;

case 'orange':

    console.log('Orange selected');

    break;

default:

    console.log('The fruit is unknown');

}

Оператор `break` додається наприкінці кожного блоку case. Функція оператора
`break` — перервати подальші перевірки й відразу перейти до коду, що йде після
`switch`, щойно виконався якийсь із блоків case. Якщо жодного збігу значень не
відбулося, необхідно виконати код за замовчуванням. Для цього в кінці після всіх
блоків `case `додається блок `default`.

Якщо `break` не вказано, виконання коду продовжиться в наступному case і далі.
Така поведінка називається `"провалюванням" (fall-through)`. Якщо потрібно, щоб
кілька блоків case виконували той самий код, можна опустити оператор break між
ними.

### **Логічні оператори**

**Перетворення типів: `логічне`**

1. Логічні значення

Логічні значення true та false залишаються незмінними.

2. Числа

Число 0, значення NaN, null і undefined завжди перетворюються на false. Усі інші
числа перетворюються на true.

3. Рядки

Порожній рядок ("") приводиться до false. Будь-які інші не пусті рядки
приводяться до true.

_`Запам'ятай 6 випадків, які приводяться до false:`_

1. 0
2. ""
3. Nan
4. null
5. undefined
6. false

**Логічне `«І» &&`**

Оператор "І" зліва направо перевіряє почергово обидва операнди на істинність та
повертає або значення останнього істинного (тільки правого) операнда, або
першого хибного (лівого чи правого), на якому він запнувся.

**Логічне `«АБО»`**

Оператор `"АБО" (||)` перетворює всі операнди до логічного типу
`(true або false)` і повертає значення одного з них. Дозволяє перевіряти, чи є
хоча б один із операндів "істинним". Обчислення оператора відбувається
`зліва направо`.

Оператор "АБО" замикається на вірному операнді і повертає значення операнда, на
якому запнувся, або значення крайнього правого операнда. Якщо лівий операнд був
перетворений на true, правий операнд не обчислюється.

**Логічне `«НІ»`**

Усі оператори, які ми розглядали раніше, були `бінарними`. Бінарні оператори
містять два операнди: лівий і правий. Логічне `«НІ»` `(!)` — це `унарний`
оператор — він виконує операцію над одним операндом праворуч.

`!expression`

### **Методи рядків**

**Властивості**

`_властивості_` — це описові характеристики сутності. У прикладі з кавою — це
колір, кількість цукру, температура. Наприклад, у програмуванні рядок має
властивість length, яка повертає кількість символів у рядку. Для доступу до
властивості використовується синтаксис із крапкою:

objectName.method

**Методи**

`_Методи_` — це дії, які можна виконати із сутністю, такі як додати цукор чи
підігріти. У програмуванні дані також заздалегідь мають певні методи, які
дозволяють виконувати різні операції, наприклад, перетворення рядка в різний
регістр. Виклик методу дуже схожий на доступ до властивості, але наприкінці
додаються круглі дужки, як при виклику функції:

objectName.method()

`_\_Mетод toUpperCase()_\_` - для перетворення рядка у верхній регістр:

const message = "JavaScript is awesome"; console.log(message.toUpperCase()); //
"JAVASCRIPT IS AWESOME"

`_\_Метод slice()_\_` використовується для створення копії частини або всього
рядка без зміни оригінального рядка.Метод slice() корисний, коли потрібно
отримати певну частину рядка або створити копію для подальшого використання, не
змінюючи вихідний рядок.

const fullName = "Jacob Mercer"; console.log(fullName.slice(0, 4)); // 'Jaco'
console.log(fullName.slice(3, 9)); // 'ob Mer' console.log(fullName.slice(0,
fullName.length)); // 'Jacob Mercer'

`_\_Методи toLowerCase( нижній регістр) і toUpperCase(верхній регістр)_\_`
використовуються для зміни регістру символів у рядку. Обидва методи не змінюють
вихідний рядок, а повертають новий рядок у відповідному регістрі.

`_\_Метод includes()_\_` використовується для перевірки наявності підрядка у
рядку. Він повертає логічне значення true, якщо підрядок знайдено, і false, якщо
підрядок відсутній.

const message = "Please buy our stuff!"; const hasSpam =
message.includes("buy");

if (hasSpam) { console.log("Warning: This message contains forbidden words."); }
else { console.log("You can safely open this message."); }

`_\_Методи startsWith() і endsWith()_\_`призначені для перевірки початку й
закінчення рядка відповідно. Вони повертають булеве значення true або false,
залежно від того, чи відповідає початок або кінець рядка заданому значенню

`_\_Метод indexOf()_\_` використовується для пошуку першого входження підрядка в
рядок. Він повертає: індекс першого входження (індекс першого символу) підрядка,
якщо він знайдений або -1, якщо підрядок не виявлено

`_\_Метод trim()_\_` використовується для видалення початкових і кінцевих
пробілів із рядка. Метод trim() не змінює вихідний рядок, а повертає новий рядок
без початкових і кінцевих пробілів.

### **Цикли**

Цикли використовуються для багаторазового повторення однієї частини коду.

`**Цикл**` — керуюча конструкція, призначена для організації багаторазового
виконання набору інструкцій.

`**Тіло циклу**` — послідовність інструкцій, призначена для багаторазового
виконання.

`**Ітерація**` — одиничне виконання тіла циклу.

`**Умова виходу**` — вираз, що визначає, чи буде в черговий раз виконуватися
ітерація, або цикл завершиться.

`**_\_Цикл while_\_**` це цикл з передумовою, тобто він виконується доки істинна
певна умова, зазначена перед його початком. Цю умову перевіряють до виконання
тіла циклу, тому тіло може бути не виконано жодного разу, якщо умова від самого
початку хибна.

let clientCounter = 18; const maxClients = 25;

while (clientCounter < maxClients) { console.log(clientCounter); clientCounter
+= 1; }

`**_\_Цикл do…while_\_**` Цикли while і do...while працюють схожим чином, але
мають одну ключову відмінність. Під час використання циклу do...while код у тілі
циклу виконується принаймні один раз, навіть якщо умова не виконується з самого
початку.

`**_\_Цикл for_\_**` також дозволяє виконувати код, що повторюється, багато
разів. На відміну від циклів while і do…while, цикл for має змінну-лічильник.
Змінна-лічильник оголошується за допомогою ключового слова `**let**` (оголошення
через `**const видасть помилку**`). На кожній ітерації після виконання коду з
тіла циклу вона змінює своє значення від заданого початкового до кінцевого з
певним кроком.

for (Ініціалізація; Умова; Пост-вираз) { // Тіло циклу }

`Ініціалізація` — виконується один раз перед початком циклу. Тут оголошується
змінна-лічильник і вказується її початкове значення.

`Умова` — це вираз, який оцінюється перед кожною ітерацією (повторенням) циклу.
Якщо умова перетворюється на**true**, то виконується тіло циклу. Якщо умова
перетворюється на false, то цикл завершується.

`Пост-вираз` — це вираз, який виконується в кінці кожної ітерації циклу, перед
перевіркою умови. Використовується для оновлення значення змінної-лічильника.

`Тіло циклу` — це блок коду, який буде виконуватися на кожній ітерації циклу,
якщо умова перетворюється на true.

**Інкремент і декремент** це операції, які відповідно збільшують або зменшують
значення числової змінної на одиницю і одразу ж зберігають оновлене значення у
цій змінній. Існують два види інкременту та декременту: `_префіксний_` і
`_постфіксний_`. Ці операції корисні, коли тобі потрібно змінювати значення
змінних одразу на одиницю, що може бути важливо, наприклад, при створенні
лічильників у циклах, замість комбінованих операторів += і -=.

`_*Інкремент*_`

Префіксний інкремент (++value) спочатку збільшує значення змінної, а потім
використовує нове значення у виразі.

Постфіксний інкремент (value++) спочатку використовує поточне значення змінної у
виразі, а потім виконує збільшення значення.

`_*Декремент*_`

Префіксний декремент (--value) спочатку зменшує значення змінної, а потім
використовує нове значення у виразі.

Постфіксний декремент (value--) спочатку використовує поточне значення змінної у
виразі, а потім виконує зменшення значення.

**Оператор break**

Оператор break використовується в циклі для переривання його виконання. Коли
оператор break зустрічається всередині циклу, виконання циклу негайно
припиняється, і керування передається до наступної інструкції після циклу.

`Оператор break і функції` оператор break не припиняє виконання функції, а
тільки перериває цикл. Для того щоб переривати виконання одразу циклу і функції
і повернути результат у зовнішній код, є оператор return.

# goit-js-hw-03

### Масиви і функції

`Масив` — це впорядкована структура даних, яка використовується для зберігання
колекції елементів. Масиви можуть містити елементи різних типів даних, таких як
числа, рядки, булеві значення тощо.

Для `створення масиву в JavaScript використовується літерал масиву`: квадратні
дужки []. Усередині дужок перераховуються елементи масиву, розділені комами. Ось
приклад створення масиву:

const planets = ['Earth', 'Mars', 'Venus']; // масив рядків

const numbers = [1, 2, 3, 4, 5]; // масив чисел

const mixed = ['apple', 10, true]; // масив з елементами різних типів

**_Доступ до елементів_**

`Масив` — це впорядкована колекція елементів, де кожен елемент має свій
порядковий номер, який називається індексом. `Індексація елементів масиву`
починається з нуля, тобто перший елемент має індекс 0, другий елемент — індекс 1
і так далі.

const planets = ['Earth', 'Mars', 'Venus'];

console.log(planets[0]); // 'Earth'

console.log(planets[1]); // 'Mars'

console.log(planets[2]); // 'Venus'

console.log(planets[3]); // undefined

**_Перевизначення значення елемента_**

Елементи масиву можна змінювати, звернувшись до них за індексом і присвоївши
нове значення. Цей процес називається "перевизначенням" значення елемента.

const planets = ['Earth', 'Mars', 'Venus', 'Uranus'];

planets[0] = 'Jupiter';

planets[2] = 'Neptune';

console.log(planets); // ['Jupiter', 'Mars', 'Neptune', 'Uranus']

**_Довжина масиву_**

Довжина масиву, тобто кількість його елементів, зберігається у властивості
length. Це динамічна величина, яка автоматично змінюється під час додавання або
видалення елементів.

const planets = ['Earth', 'Mars', 'Venus'];

console.log(planets.length); // 3

**_Індекс останнього елемента_**

Щоб знайти значення останнього елемента масиву, нам потрібно знати його індекс.
Індекс останнього елемента можна визначити за допомогою формули довжина_масиву
-1.

Оскільки індексація елементів масиву починається з 0, а довжина масиву зберігає
загальну кількість елементів, віднімаючи 1 від довжини масиву, ми отримуємо
індекс останнього елемента.

const planets = ["Earth", "Mars", "Venus"];

const lastElementIndex = planets.length - 1;

console.log(planets[lastElementIndex]); // "Venus"

**_Присвоєння за посиланням і за значенням_**

Фундаментальною відмінністю складних типів від примітивів є те, як вони
зберігаються і копіюються.

Примітиви: рядки, числа, буль, null і undefined, під час присвоювання копіюються
цілком, за значенням `(by value)`. Усі примітивні типи присвоюються за
значенням, тобто створюється копія.

let a = 5;

let b = a; // копія значення

b = 10;

console.log(a); // 5 (не змінився)

Зі складними типами все не так. У змінній, якій, наприклад, присвоєно масив,
зберігаються не самі значення елементів масиву, а адреса того місця в пам'яті,
де цей масив розташовано. Іншими словами — посилання (покажчик) на нього.

const user1 = { name: "Ana" };

const user2 = user1; // те саме посилання

user2.name = "Bogdan";

console.log(user1.name); // "Bogdan" (зміни видно в обох)

Отже, вони передаються за посиланням `(by reference)`.Масиви (складний тип)
присвоюються за посиланням, тобто змінна просто отримує посилання (покажчик у
пам'яті) на вже існуючий масив. Два масиви ніколи не дорівнюють один одному,
навіть якщо вони порожні або в них однакові елементи.

const arr1 = [1, 2];

const arr2 = arr1; // спільне посилання

arr2.push(3);

console.log(arr1); // [1, 2, 3]

**_Приведення типів: масиви_**

Явне і не явне приведення типів масивів здійснюється за необхідності виконати
операції або порівняння, які вимагають сумісності типів даних.

`Масив → Рядок`

При перетворенні масиву в рядок усі елементи масиву об'єднуються в один рядок,
розділений комами.

const array = [1, true, "Poly"];

console.log(String(array));// "1,true,Poly"

console.log(array + "5"); // "1,true,Poly5"

`Масив → Число`

При перетворенні масиву в число алгоритм складається з двох кроків:

спочатку масив приводиться до рядка, а потім цей рядок приводиться до числового
значення.

Наприклад, порожній масив приводиться до порожнього рядка, який приводиться до
числа 0.

console.log(Number([])); // 0

console.log(Number([1])); // 1

console.log(Number([1, 2, 3])); // NaN

`Масив → Логічне значення (буль)`

При перетворенні масиву в логічне значення будь-який масив, навіть порожній,
перетворюється на `true`.

**_Методи масиву_**

Методи масиву дозволяють додавати, видаляти, змінювати та виконувати інші
операції над елементами масиву.

`Метод join()`

Метод масиву join(delimiter) дозволяє об'єднати елементи масиву в рядок. У
результуючому рядку елементи будуть розділені символом або групою символів,
зазначених у delimiter.

const words = ["JavaScript", "is", "amazing"];

console.log(words.join("")); // 'JavaScriptisamazing'

console.log(words.join(" ")); // 'JavaScript is amazing'

console.log(words.join("-")); // 'JavaScript-is-amazing'

`Метод split()`

Метод рядків split(delimiter) виконує зворотну операцію порівняно з методом
масивів join(delimiter). Він дозволяє перетворити рядок на масив, розбивши його
за вказаним роздільником delimiter.

const name = "Mango";

const letters = name.split("");

console.log(letters); // ["M", "a", "n", "g", "o"]

const message = "JavaScript essentials";

const words = message.split(" ");

console.log(words); // ["JavaScript", "essentials"]

const slug = "amazing-french-recipes";

const slugParts = slug.split("-");

console.log(slugParts); // ["amazing", "french", "recipes"]

`Метод slice()`

Метод масиву slice(begin, end) повертає новий масив, що містить копію частини
вихідного масиву, не змінюючи його. Копія створюється від індексу begin до, але
не включаючи індекс end.

const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];

console.log(planets.slice(0, 2)); // ['Earth', 'Mars']

console.log(planets.slice(0, 4)); // ['Earth', 'Mars', 'Venus', 'Jupiter']

console.log(planets.slice(1, 3)); // ['Mars', 'Venus']

Якщо `не вказати параметри begin і end`, буде створено повну копію вихідного
масиву:

console.log(planets.slice()); // ["Earth", "Mars", "Venus", "Jupiter", "Saturn"]

Якщо `не вказати end`, копіювання відбуватиметься від begin до кінця масиву:

console.log(planets.slice(2)); // ["Venus", "Jupiter", "Saturn"]

Якщо `значення begin негативне`, а end не вказано, будуть скопійовані останні
begin елементів (тобто стільки елементів з кінця, скільки вказано в параметрі
begin):

console.log(planets.slice(-2)); // ["Jupiter", "Saturn"]

`Метод concat()`

Метод concat(arr1, arr2, ..., arrN) використовується для об'єднання двох або
більше масивів. Зверни увагу, що вихідні масиви firstArray і secondArray
залишаються незмінними після виклику concat(). Метод concat() створює і повертає
новий масив, що містить усі елементи об'єднаних масивів. Порядок аргументів
методу визначає порядок розташування елементів у новому масиві.

const firstArray = ["Mercury", "Venus"];

const secondArray = ["Mars", "Jupiter"];

const result = firstArray.concat(secondArray);

console.log(firstArray); // ["Mercury", "Venus"];

console.log(secondArray); // ["Mars", "Jupiter"];

console.log(result); // ["Mercury", "Venus", "Mars", "Jupiter"];

`Метод indexOf()`

Метод масиву indexOf(elem) використовується для визначення індексу першого
входження елемента elem у масиві. Він повертає індекс елемента, якщо він
знайдений, або -1, якщо елемент не знайдений. Метод indexOf() виконує сувору
рівність (===) при порівнянні елементів.

const clients = ["Mango", "Ajax", "Poly", "Kiwi", "Poly"];

console.log(clients.indexOf("Poly")); // 2

console.log(clients.indexOf("Monkong")); // -1

`Метод push()`

Метод масиву push() використовується для додавання одного або більше елементів у
кінець масиву.За допомогою циклу ми можемо виконувати повторювані операції і
використовувати метод push для додавання нових елементів у масив на кожній
ітерації. Це дуже корисно, коли нам потрібно створити масив з елементами, які
можна динамічно додавати.

const planets = ["Earth", "Mars", "Venus"];

planets.push("Jupiter");

console.log(planets); // ['Earth', 'Mars', 'Venus', 'Jupiter']

planets.push("Saturn", "Neptune");

console.log(planets); // ['Earth', 'Mars', 'Venus', 'Jupiter', "Saturn",
"Neptune"]

**_Ітерація по масиву_**

Ітерація по масиву з використанням циклу for дозволяє перебрати елементи масиву
і виконати певну дію для кожного елемента.

const planets = ["Earth", "Mars", "Venus"];

for (let i = 0; i < planets.length; i += 1) { console.log(planets[i]); }

---

function getEvenNumbers(start, end) {

const result = [];

for (let i = start; i <= end; i += 1) {

    if (i % 2 === 0) {

      result.push(i);

    }

}

return result;

}

`Метод includes()`

Метод масиву includes() використовується для перевірки наявності певного
елемента в масиві. Він повертає логічне значення
`true`,`якщо елемент знайдено в масиві, і`false`, якщо елемент відсутній.

const planets = ["Earth", "Mars", "Venus"];

console.log(planets.includes("Earth")); // true

console.log(planets.includes("Mars")); // true

console.log(planets.includes("Venus")); // true

console.log(planets.includes("Jupiter")); // false

---

Метод includes() можна поєднувати з розгалуженнями для перевірки умов.

const fruits = ["apple", "banana", "orange"];

if (fruits.includes("banana")) {

console.log("The array has an element banana");

} else {

console.log("Array does not contain banana element");

}

`Цикл for...of`

Цикл for...of — це зручний спосіб перебору масиву. Тіло циклу буде виконуватися
на кожному елементі масиву. Це гарна заміна циклу for, якщо не потрібен доступ
до лічильника. Цикл for...of завжди перебирає масив від першого і до останнього
елемента, задати умову припинення циклу не можна. Якщо необхідно закінчити
виконання циклу передчасно, використовується вже знайомий оператор break.

const planets = ["Earth", "Mars", "Venus"];

for (const planet of planets) {

console.log(planet);

}

**_Функції (частина 2)_**

`Псевдомасив arguments`

Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної
arguments. Коли ти викликаєш функцію з аргументами, arguments автоматично
створюється всередині цієї функції і заповнюється переданими значеннями
аргументів. Ця колекція схожа на масив, але насправді є псевдомасивом, тобто:

у неї є деякі властивості масивів, наприклад length;

у неї є можливість звернутися до елемента за індексом;

у неї немає методів для роботи з масивом;

її можна перебирати за допомогою циклів.

---

function multiply() {

let total = 1;

for (const arg of arguments) {

    total *= arg;

}

return total; }

console.log(multiply(1, 2, 3)); // 6

console.log(multiply(1, 2, 3, 4)); // 24

console.log(multiply(1, 2, 3, 4, 5)); // 120

---

Якщо під час роботи з `arguments` потрібно використовувати методи масиву, тоді
псевдомасив необхідно перетворити на масив, використовуючи метод `Array.from()`,
який створить масив із псевдомасиву.

function foo() { // У змінній args буде повноцінний масив з усіх аргументів

const args = Array.from(arguments);

    return args.join("-");

}

foo(1, 2, 3); // Поверне "1-2-3"

`*Параметри за замовчуванням*`

Функції можуть мати параметри зі значеннями за замовчуванням, тобто
необов'язкові параметри. Ці значення використовуються в тому випадку, якщо
функція викликається без передавання відповідного аргументу для цього параметра.
Значенням за замовчуванням може бути будь-який тип даних.

function greet(username = "Guest") {

console.log(`Hello, ${username}!`);

}

greet("Jacob"); // "Hello, Jacob!"

greet(); // "Hello, Guest!"

`Функціональний вираз (function expression)` — звичайне оголошення змінної,
значенням якої буде функція. Це альтернативний спосіб оголошення функції.

Синтаксис оголошення функції, який ти вже знаєш `(function declaration)`:

function multiply(x, y, z) {

console.log(x _ y _ z); }

Синтаксис функціонального виразу `(function expression)`:

const multiply = function (x, y, z) {

console.log(x _ y _ z); };

**Різниця** в тому, що функціональний вираз
`(function expression) не можна викликати до місця його створення`, тільки
після, тому що це буквально оголошення const змінної. A оголошення функції
`(function declaration) можна викликати до місця її створення` в коді.

`Область видимості (scope)` — механізм, який визначає доступність змінних у
коді, що виконується.

`Ланцюжок областей видимості (scope chain)` — області видимості утворюють
ієрархію, так що дочірні області мають доступ до змінних із батьківських
областей, але не навпаки.

Змінна видима для виконуваного коду, якщо вона є:

в поточній області видимості або в ланцюжку областей видимості.

Змінні, оголошені на найвищому рівні, тобто поза будь-якими конструкціями
наприклад: if, for і функцій — перебувають у глобальній області видимості і
доступні скрізь після їхнього оголошення.

Змінні, оголошені всередині інструкційif, for, функцій та інших блоків коду, що
огорнуті фігурними дужками {}, перебувають у блоковій області видимості та
доступні тільки всередині цього блоку коду або вкладених у нього.

`Стек викликів`

Під час виклику функції всередині її тіла можуть викликатися інші функції, а в
них інші тощо.

`JavaScript — однопотокова мова`, тобто в одну одиницю часу може виконуватися
тільки одна інструкція. Це означає, що вже викликані функції, які не закінчили
своє виконання, повинні чекати виконання функцій, викликаних усередині себе, для
того щоб продовжити свою роботу.

Щоб код працював контрольовано й очікувано, потрібен механізм зберігання списку
функцій, які були викликані, але ще не закінчили своє виконання, і механізм
управління послідовністю виконання цих функцій. Саме за це й відповідає стек
викликів `(call stack)`.

`Стек` — структура даних, яка працює за принципом LIFO (Last-In-First-Out),
тобто останнім прийшов — першим вийшов.

`Стек викликів (call stack)` — це структура даних, яка допомагає інтерпретатору
відстежувати послідовність і стан викликів функцій у програмі. Він показує, яка
функція зараз виконується і яка буде викликана наступною.

Коли в коді викликається функція, інтерпретатор додає її в стек викликів і
починає виконання. Будь-які функції, викликані виконуваною функцією, додаються
до стеку викликів і виконуються, щойно відбувається їхній виклик. Коли виконання
функції завершено, інтерпретатор знімає її зі стеку викликів і відновлює
виконання коду з тієї точки, де зупинився до цього. Тобто починає виконуватися
функція, запис якої лежить наступною на стеку.

`Stack frame (кадр стека, запис стека)` — структура, яка додається на стек при
виклику функції. Зберігає службову інформацію, наприклад ім'я функції та номер
рядка, у якому стався виклик.

Стек викликів не безмежний, йому відводиться кінцевий обсяг пам'яті. Іноді в
консолі можна побачити помилку "Uncaught RangeError: Maximum call stack size
exceeded" — `переповнення стека (stack overflow)`.

Це може статися при зациклюванні викликів функцій, тобто якщо йдуть нескінченні
виклики функцій і результат не повертається, то стек збільшується. Наприклад,
якщо функція викликає сама себе, що називається `рекурсією`. По досягненню межі
кількості записів стека і виникне така помилка, і скрипт "падає".
